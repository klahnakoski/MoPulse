diff --git a/mozillapulse/consumers.py b/mozillapulse/consumers.py
index ab5df19..8102c57 100644
--- a/mozillapulse/consumers.py
+++ b/mozillapulse/consumers.py
@@ -2,15 +2,17 @@
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
+import logging
 import uuid
+from socket import timeout as socket_timeout
 
 from amqp import ChannelError
 from kombu import Connection, Exchange, Queue
 
-from config import PulseConfiguration
-from utils import *
+from mozillapulse.config import PulseConfiguration
+from mozillapulse.publishers import InvalidExchange
+
 
-# Exceptions we can raise
 class InvalidTopic(Exception):
     pass
 
@@ -31,14 +33,15 @@ class GenericConsumer(object):
     somewhere, e.g. the constructor.
     """
 
-    def __init__(self, config, exchange=None, connect=True, heartbeat=False,
+    def __init__(self, config, exchange=None, connect=True, heartbeat=False, timeout=None,
                  **kwargs):
         self.config = config
         self.exchange = exchange
         self.connection = None
         self.durable = False
         self.applabel = ''
-        self.heartbeat = heartbeat
+        self.heartbeat = heartbeat,
+        self.timeout = timeout
         for x in ['applabel', 'topic', 'callback', 'durable']:
             if x in kwargs:
                 setattr(self, x, kwargs[x])
@@ -133,7 +136,13 @@ class GenericConsumer(object):
         For info on one script listening to multiple channels, see
         http://ask.github.com/carrot/changelog.html#id1.
         """
+        while True:
+            consumer = self._build_consumer(callback=callback, on_connect_callback=on_connect_callback)
+            with consumer:
+                self._drain_events_loop()
+
 
+    def _build_consumer(self, callback=None, on_connect_callback=None):
         # One can optionally provide a callback to listen (if it wasn't already)
         if callback:
             self.callback = callback
@@ -170,12 +179,21 @@ class GenericConsumer(object):
             hb_exchange = Exchange('exchange/pulse/test', type='topic')
             consumer.queues[0].bind_to(hb_exchange, 'heartbeat')
 
-        with consumer:
-            while True:
-                self.connection.drain_events()
+        return consumer
+
+    def _drain_events_loop(self):
+        while True:
+            try:
+                self.connection.drain_events(timeout=self.timeout)
+            except socket_timeout, e:
+                log_warning("timeout! Restarting pulse consumer.", cause=e)
+                try:
+                    self.disconnect()
+                except Exception, f:
+                    log_warning("Problem with disconnect()", cause=f)
+                break
+
 
-        # Likely never get here but can't hurt.
-        self.disconnect()
 
     def _check_params(self):
         if not self.exchange:
@@ -265,3 +283,15 @@ class MozReviewConsumer(GenericConsumer):
     def __init__(self, **kwargs):
         super(MozReviewConsumer, self).__init__(
             PulseConfiguration(**kwargs), 'exchange/mozreview/', **kwargs)
+
+
+def log_warning(message, cause=None):
+    """
+    A structured logger is expected to override this method,
+    until then we default to standard Python logging
+
+    :param message: Describe the problem
+    :param cause: Exception that caused problem (for chaining)
+    :return: None
+    """
+    logging.warning(message)
